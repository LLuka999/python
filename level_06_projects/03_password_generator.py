#!/usr/bin/env python3
"""
üîê G√©n√©rateur de Mots de Passe - M√©thode Markova
=================================================

Un g√©n√©rateur de mots de passe s√©curis√© qui propose :
- G√©n√©ration avec crit√®res personnalisables
- √âvaluation de la force du mot de passe
- Plusieurs m√©thodes de g√©n√©ration
- Conseils de s√©curit√©
- Export s√©curis√©

Auteur: M√©thode Markova
Niveau: 06 - Mini-projets concrets
"""

import random
import string
import secrets
import re
import json
from typing import Dict, List, Tuple, Optional
from dataclasses import dataclass


@dataclass
class PasswordCriteria:
    """Crit√®res pour la g√©n√©ration de mots de passe."""
    length: int = 12
    use_uppercase: bool = True
    use_lowercase: bool = True
    use_digits: bool = True
    use_symbols: bool = True
    exclude_ambiguous: bool = True
    exclude_chars: str = ""
    must_include: str = ""


class PasswordGenerator:
    """G√©n√©rateur de mots de passe s√©curis√©."""
    
    def __init__(self):
        """Initialise le g√©n√©rateur."""
        # Caract√®res ambigus √† √©viter par d√©faut
        self.ambiguous_chars = "0O1lI|`"
        
        # Jeux de caract√®res
        self.uppercase = string.ascii_uppercase
        self.lowercase = string.ascii_lowercase
        self.digits = string.digits
        self.symbols = "!@#$%^&*()_+-=[]{}|;:,.<>?"
    
    def _get_character_pool(self, criteria: PasswordCriteria) -> str:
        """
        Construit le pool de caract√®res selon les crit√®res.
        
        Args:
            criteria: Crit√®res de g√©n√©ration
            
        Returns:
            String contenant tous les caract√®res utilisables
        """
        pool = ""
        
        if criteria.use_uppercase:
            pool += self.uppercase
        if criteria.use_lowercase:
            pool += self.lowercase
        if criteria.use_digits:
            pool += self.digits
        if criteria.use_symbols:
            pool += self.symbols
        
        # Supprime les caract√®res ambigus si demand√©
        if criteria.exclude_ambiguous:
            pool = ''.join(c for c in pool if c not in self.ambiguous_chars)
        
        # Supprime les caract√®res exclus personnalis√©s
        if criteria.exclude_chars:
            pool = ''.join(c for c in pool if c not in criteria.exclude_chars)
        
        return pool
    
    def generate_random(self, criteria: PasswordCriteria) -> str:
        """
        G√©n√®re un mot de passe al√©atoire.
        
        Args:
            criteria: Crit√®res de g√©n√©ration
            
        Returns:
            Mot de passe g√©n√©r√©
        """
        pool = self._get_character_pool(criteria)
        
        if not pool:
            raise ValueError("Aucun caract√®re disponible avec ces crit√®res")
        
        # G√©n√©ration s√©curis√©e avec secrets
        password = ''.join(secrets.choice(pool) for _ in range(criteria.length))
        
        # S'assure que le mot de passe respecte les exigences minimales
        password = self._ensure_criteria_met(password, criteria)
        
        # Ajoute les caract√®res obligatoires si sp√©cifi√©s
        if criteria.must_include:
            password = self._include_required_chars(password, criteria)
        
        return password
    
    def generate_pronounceable(self, length: int = 12) -> str:
        """
        G√©n√®re un mot de passe pronon√ßable (alternance voyelles/consonnes).
        
        Args:
            length: Longueur du mot de passe
            
        Returns:
            Mot de passe pronon√ßable
        """
        vowels = "aeiou"
        consonants = "bcdfghjklmnpqrstvwxyz"
        
        password = ""
        for i in range(length):
            if i % 2 == 0:  # Position paire = consonne
                password += secrets.choice(consonants)
            else:  # Position impaire = voyelle
                password += secrets.choice(vowels)
        
        # Ajoute quelques chiffres et majuscules pour la s√©curit√©
        if length > 6:
            # Remplace quelques caract√®res par des majuscules
            password = self._add_random_case(password)
            # Ajoute quelques chiffres
            password = self._add_random_digits(password, min(2, length // 4))
        
        return password
    
    def generate_passphrase(self, word_count: int = 4, separator: str = "-") -> str:
        """
        G√©n√®re une phrase de passe avec des mots al√©atoires.
        
        Args:
            word_count: Nombre de mots
            separator: S√©parateur entre les mots
            
        Returns:
            Phrase de passe
        """
        # Liste de mots courants mais non triviaux
        words = [
            "horizon", "cascade", "thunder", "whisper", "crystal", "phoenix", "glacier",
            "bambou", "tornade", "mystere", "lumiere", "aventure", "courage", "silence",
            "orange", "violet", "bronze", "argent", "rubine", "saphir", "emeraude",
            "montagne", "riviere", "foret", "desert", "ocean", "planete", "etoile",
            "papillon", "libellule", "colibri", "elephant", "panthere", "dolphin",
            "keyboard", "melody", "rhythm", "harmony", "symphony", "poetry", "canvas"
        ]
        
        selected_words = [secrets.choice(words) for _ in range(word_count)]
        
        # Ajoute un nombre al√©atoire pour plus de s√©curit√©
        selected_words.append(str(secrets.randbelow(9999)))
        
        return separator.join(selected_words)
    
    def _ensure_criteria_met(self, password: str, criteria: PasswordCriteria) -> str:
        """
        S'assure que le mot de passe respecte tous les crit√®res.
        
        Args:
            password: Mot de passe √† v√©rifier
            criteria: Crit√®res requis
            
        Returns:
            Mot de passe modifi√© si n√©cessaire
        """
        pool = self._get_character_pool(criteria)
        password_list = list(password)
        
        # V√©rifie et corrige chaque crit√®re
        if criteria.use_uppercase and not any(c in self.uppercase for c in password):
            pos = secrets.randbelow(len(password_list))
            password_list[pos] = secrets.choice(self.uppercase)
        
        if criteria.use_lowercase and not any(c in self.lowercase for c in password):
            pos = secrets.randbelow(len(password_list))
            password_list[pos] = secrets.choice(self.lowercase)
        
        if criteria.use_digits and not any(c in self.digits for c in password):
            pos = secrets.randbelow(len(password_list))
            password_list[pos] = secrets.choice(self.digits)
        
        if criteria.use_symbols and not any(c in self.symbols for c in password):
            pos = secrets.randbelow(len(password_list))
            password_list[pos] = secrets.choice(self.symbols)
        
        return ''.join(password_list)
    
    def _include_required_chars(self, password: str, criteria: PasswordCriteria) -> str:
        """
        Inclut les caract√®res obligatoires dans le mot de passe.
        
        Args:
            password: Mot de passe de base
            criteria: Crit√®res avec caract√®res requis
            
        Returns:
            Mot de passe avec caract√®res requis
        """
        password_list = list(password)
        
        for char in criteria.must_include:
            if char not in password_list:
                # Remplace un caract√®re al√©atoire
                pos = secrets.randbelow(len(password_list))
                password_list[pos] = char
        
        return ''.join(password_list)
    
    def _add_random_case(self, password: str) -> str:
        """Ajoute des majuscules al√©atoires."""
        password_list = list(password.lower())
        for _ in range(len(password_list) // 3):
            pos = secrets.randbelow(len(password_list))
            if password_list[pos].isalpha():
                password_list[pos] = password_list[pos].upper()
        return ''.join(password_list)
    
    def _add_random_digits(self, password: str, count: int) -> str:
        """Ajoute des chiffres al√©atoires."""
        password_list = list(password)
        for _ in range(count):
            pos = secrets.randbelow(len(password_list))
            password_list[pos] = secrets.choice(self.digits)
        return ''.join(password_list)


class PasswordStrengthAnalyzer:
    """Analyseur de force des mots de passe."""
    
    def analyze(self, password: str) -> Dict[str, any]:
        """
        Analyse la force d'un mot de passe.
        
        Args:
            password: Mot de passe √† analyser
            
        Returns:
            Dictionnaire avec l'analyse d√©taill√©e
        """
        if not password:
            return {"score": 0, "level": "Invalide", "feedback": ["Mot de passe vide"]}
        
        score = 0
        feedback = []
        
        # Crit√®res d'√©valuation
        length = len(password)
        has_lower = bool(re.search(r'[a-z]', password))
        has_upper = bool(re.search(r'[A-Z]', password))
        has_digit = bool(re.search(r'\d', password))
        has_symbol = bool(re.search(r'[!@#$%^&*()_+\-=\[\]{}|;:,.<>?]', password))
        
        # Calcul du score
        if length >= 8:
            score += 1
        if length >= 12:
            score += 1
        if length >= 16:
            score += 1
        
        if has_lower:
            score += 1
        if has_upper:
            score += 1
        if has_digit:
            score += 1
        if has_symbol:
            score += 1
        
        # V√©rifications suppl√©mentaires
        unique_chars = len(set(password))
        if unique_chars >= length * 0.7:  # 70% de caract√®res uniques
            score += 1
        
        # P√©nalit√©s
        if re.search(r'(.)\1{2,}', password):  # R√©p√©titions
            score -= 1
            feedback.append("√âvitez les r√©p√©titions de caract√®res")
        
        if re.search(r'(012|123|234|345|456|567|678|789|890)', password):  # S√©quences
            score -= 1
            feedback.append("√âvitez les s√©quences num√©riques")
        
        if re.search(r'(abc|bcd|cde|def|efg|fgh|ghi|hij|ijk|jkl|klm|lmn|mno|nop|opq|pqr|qrs|rst|stu|tuv|uvw|vwx|wxy|xyz)', password.lower()):
            score -= 1
            feedback.append("√âvitez les s√©quences alphab√©tiques")
        
        # Mots de passe courants
        common_passwords = ['password', 'motdepasse', '12345678', 'qwerty', 'azerty']
        if password.lower() in common_passwords:
            score = 0
            feedback.append("Mot de passe trop courant")
        
        # Recommandations
        if not has_lower:
            feedback.append("Ajoutez des lettres minuscules")
        if not has_upper:
            feedback.append("Ajoutez des lettres majuscules")
        if not has_digit:
            feedback.append("Ajoutez des chiffres")
        if not has_symbol:
            feedback.append("Ajoutez des symboles (!@#$%...)")
        if length < 12:
            feedback.append("Utilisez au moins 12 caract√®res")
        
        # D√©termination du niveau
        if score <= 2:
            level = "Tr√®s faible"
            color = "üî¥"
        elif score <= 4:
            level = "Faible"
            color = "üü†"
        elif score <= 6:
            level = "Moyen"
            color = "üü°"
        elif score <= 8:
            level = "Fort"
            color = "üü¢"
        else:
            level = "Tr√®s fort"
            color = "üíö"
        
        return {
            "score": score,
            "max_score": 9,
            "level": level,
            "color": color,
            "feedback": feedback,
            "details": {
                "length": length,
                "has_lowercase": has_lower,
                "has_uppercase": has_upper,
                "has_digits": has_digit,
                "has_symbols": has_symbol,
                "unique_chars": unique_chars
            }
        }


def show_password_tips() -> None:
    """Affiche des conseils de s√©curit√©."""
    print("\nüõ°Ô∏è  CONSEILS DE S√âCURIT√â:")
    print("=" * 50)
    print("‚úÖ Utilisez un mot de passe unique pour chaque compte")
    print("‚úÖ Minimum 12 caract√®res (16+ recommand√©)")
    print("‚úÖ M√©langez majuscules, minuscules, chiffres et symboles")
    print("‚úÖ √âvitez les informations personnelles")
    print("‚úÖ Utilisez un gestionnaire de mots de passe")
    print("‚úÖ Activez l'authentification √† deux facteurs")
    print("‚ùå N'utilisez jamais le m√™me mot de passe partout")
    print("‚ùå √âvitez les mots du dictionnaire")
    print("‚ùå Ne partagez jamais vos mots de passe")


def interactive_criteria_setup() -> PasswordCriteria:
    """Configuration interactive des crit√®res."""
    print("\n‚öôÔ∏è  CONFIGURATION DU MOT DE PASSE:")
    print("-" * 40)
    
    try:
        length = int(input("üî¢ Longueur [12] : ") or "12")
        length = max(4, min(128, length))  # Limite entre 4 et 128
        
        use_upper = input("üî§ Majuscules ? [O/n] : ").lower() not in ['n', 'non', 'no']
        use_lower = input("üî§ Minuscules ? [O/n] : ").lower() not in ['n', 'non', 'no']
        use_digits = input("üî¢ Chiffres ? [O/n] : ").lower() not in ['n', 'non', 'no']
        use_symbols = input("üî£ Symboles ? [O/n] : ").lower() not in ['n', 'non', 'no']
        
        exclude_ambiguous = input("üö´ Exclure caract√®res ambigus (0O1lI|) ? [O/n] : ").lower() not in ['n', 'non', 'no']
        
        exclude_chars = input("üö´ Caract√®res √† exclure (optionnel) : ").strip()
        must_include = input("‚úÖ Caract√®res √† inclure (optionnel) : ").strip()
        
        return PasswordCriteria(
            length=length,
            use_uppercase=use_upper,
            use_lowercase=use_lower,
            use_digits=use_digits,
            use_symbols=use_symbols,
            exclude_ambiguous=exclude_ambiguous,
            exclude_chars=exclude_chars,
            must_include=must_include
        )
    
    except ValueError:
        print("‚ùå Valeur invalide, utilisation des param√®tres par d√©faut")
        return PasswordCriteria()


def main():
    """Fonction principale avec interface interactive."""
    generator = PasswordGenerator()
    analyzer = PasswordStrengthAnalyzer()
    
    print("üîê G√âN√âRATEUR DE MOTS DE PASSE - M√âTHODE MARKOVA")
    print("=" * 60)
    
    while True:
        print("\nüéØ OPTIONS:")
        print("1. üîÄ G√©n√©rer mot de passe al√©atoire")
        print("2. üó£Ô∏è  G√©n√©rer mot de passe pronon√ßable")
        print("3. üìù G√©n√©rer phrase de passe")
        print("4. ‚öôÔ∏è  Configuration personnalis√©e")
        print("5. üîç Analyser un mot de passe")
        print("6. üõ°Ô∏è  Conseils de s√©curit√©")
        print("0. üö™ Quitter")
        print("-" * 50)
        
        choice = input("üëâ Votre choix : ").strip()
        
        try:
            if choice == "0":
                print("üëã Restez en s√©curit√© !")
                break
            
            elif choice == "1":
                criteria = PasswordCriteria()  # Crit√®res par d√©faut
                password = generator.generate_random(criteria)
                analysis = analyzer.analyze(password)
                
                print(f"\nüîê Mot de passe g√©n√©r√© :")
                print(f"üìã {password}")
                print(f"\nüéØ Force : {analysis['color']} {analysis['level']} ({analysis['score']}/{analysis['max_score']})")
                
                if analysis['feedback']:
                    print("üí° Suggestions :")
                    for tip in analysis['feedback'][:3]:
                        print(f"   ‚Ä¢ {tip}")
            
            elif choice == "2":
                try:
                    length = int(input("üî¢ Longueur [12] : ") or "12")
                    length = max(6, min(32, length))
                except ValueError:
                    length = 12
                
                password = generator.generate_pronounceable(length)
                analysis = analyzer.analyze(password)
                
                print(f"\nüó£Ô∏è  Mot de passe pronon√ßable :")
                print(f"üìã {password}")
                print(f"\nüéØ Force : {analysis['color']} {analysis['level']} ({analysis['score']}/{analysis['max_score']})")
            
            elif choice == "3":
                try:
                    word_count = int(input("üî¢ Nombre de mots [4] : ") or "4")
                    word_count = max(2, min(8, word_count))
                except ValueError:
                    word_count = 4
                
                separator = input("üîó S√©parateur [-] : ") or "-"
                
                passphrase = generator.generate_passphrase(word_count, separator)
                analysis = analyzer.analyze(passphrase)
                
                print(f"\nüìù Phrase de passe :")
                print(f"üìã {passphrase}")
                print(f"\nüéØ Force : {analysis['color']} {analysis['level']} ({analysis['score']}/{analysis['max_score']})")
            
            elif choice == "4":
                criteria = interactive_criteria_setup()
                password = generator.generate_random(criteria)
                analysis = analyzer.analyze(password)
                
                print(f"\nüîê Mot de passe personnalis√© :")
                print(f"üìã {password}")
                print(f"\nüéØ Force : {analysis['color']} {analysis['level']} ({analysis['score']}/{analysis['max_score']})")
                
                if analysis['feedback']:
                    print("üí° Suggestions :")
                    for tip in analysis['feedback']:
                        print(f"   ‚Ä¢ {tip}")
            
            elif choice == "5":
                password = input("üîç Entrez le mot de passe √† analyser : ").strip()
                if password:
                    analysis = analyzer.analyze(password)
                    
                    print(f"\nüìä ANALYSE D√âTAILL√âE:")
                    print("-" * 30)
                    print(f"üéØ Force : {analysis['color']} {analysis['level']}")
                    print(f"üìä Score : {analysis['score']}/{analysis['max_score']}")
                    print(f"üìè Longueur : {analysis['details']['length']} caract√®res")
                    print(f"üî§ Minuscules : {'‚úÖ' if analysis['details']['has_lowercase'] else '‚ùå'}")
                    print(f"üî§ Majuscules : {'‚úÖ' if analysis['details']['has_uppercase'] else '‚ùå'}")
                    print(f"üî¢ Chiffres : {'‚úÖ' if analysis['details']['has_digits'] else '‚ùå'}")
                    print(f"üî£ Symboles : {'‚úÖ' if analysis['details']['has_symbols'] else '‚ùå'}")
                    print(f"üé® Caract√®res uniques : {analysis['details']['unique_chars']}")
                    
                    if analysis['feedback']:
                        print("\nüí° Recommandations :")
                        for tip in analysis['feedback']:
                            print(f"   ‚Ä¢ {tip}")
                else:
                    print("‚ùå Aucun mot de passe saisi")
            
            elif choice == "6":
                show_password_tips()
            
            else:
                print("‚ùå Choix invalide")
        
        except KeyboardInterrupt:
            print("\n\nüëã Programme interrompu !")
            break
        except Exception as e:
            print(f"‚ùå Erreur : {e}")


if __name__ == "__main__":
    main() 